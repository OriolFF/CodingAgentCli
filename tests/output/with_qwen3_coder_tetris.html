<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Classic Tetris</title>
<style>
:root {
  font-family: 'Segoe UI', sans-serif;
  background: #101014;
  color: #f4f4f4;
}
* { box-sizing: border-box; }
body {
  margin: 0;
  display: flex;
  min-height: 100vh;
  align-items: center;
  justify-content: center;
}
main {
  display: grid;
  grid-template-columns: 2fr 1fr;
  gap: 1.5rem;
  padding: 2rem;
  background: linear-gradient(145deg, #151b2a, #0c101b);
  border-radius: 1.2rem;
  box-shadow: 0 20px 45px rgba(0,0,0,0.65);
}
canvas {
  width: 360px;
  height: 720px;
  border-radius: 1rem;
  background: #05090f;
  box-shadow: inset 0 0 25px rgba(0,0,0,0.8), 0 10px 30px rgba(0,0,0,0.45);
}
aside {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}
.card {
  background: rgba(255,255,255,0.05);
  border-radius: 1rem;
  padding: 1rem;
  border: 1px solid rgba(255,255,255,0.12);
  box-shadow: 0 15px 30px rgba(0,0,0,0.4);
}
.card h2 {
  margin: 0 0 0.5rem;
  font-size: 1.1rem;
  color: #94e3ff;
}
.stats {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(120px,1fr));
  gap: 0.5rem;
}
.stats span {
  display: block;
  font-size: 0.85rem;
  text-transform: uppercase;
  letter-spacing: 0.1rem;
  color: #a8b2ff;
}
.stats strong {
  font-size: 1.4rem;
}
.grid-preview {
  display: grid;
  grid-template-columns: repeat(4,1fr);
  gap: 0.2rem;
  width: 160px;
  height: 160px;
  background: #05090f;
  border-radius: 0.8rem;
  padding: 0.5rem;
}
.preview-cell {
  aspect-ratio: 1;
  border-radius: 0.3rem;
  background: rgba(255,255,255,0.03);
}
.light {
  color: #f4f4f4;
}
.blurred {
  opacity: 0.4;
}
.level-progress {
  background: rgba(255,255,255,0.08);
  border-radius: 999px;
  height: 8px;
  overflow: hidden;
}
.level-progress span {
  display: block;
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, #94e3ff, #3b71ff);
  transition: width 0.3s ease;
}
button {
  margin-top: 0.5rem;
  width: 100%;
  border: none;
  border-radius: 0.6rem;
  padding: 0.9rem;
  background: linear-gradient(135deg, #ff5f6d, #ffc371);
  color: #05090f;
  font-weight: 700;
  letter-spacing: 0.05rem;
  cursor: pointer;
  transition: transform 0.3s ease;
}
button:active {
  transform: scale(0.98);
}
@media (max-width: 900px) {
  body {
    align-items: flex-start;
    padding: 2rem;
  }
  main { grid-template-columns: 1fr; }
  canvas { width: 320px; height: 640px; }
}
</style>
</head>
<body>
<main>
  <canvas id="tetris" width="240" height="480"></canvas>
  <aside>
    <div class="card">
      <h2>Upcoming</h2>
      <div id="preview" class="grid-preview"></div>
    </div>
    <div class="card stats">
      <div>
        <span>Score</span>
        <strong id="score">0</strong>
      </div>
      <div>
        <span>Lines</span>
        <strong id="lines">0</strong>
      </div>
      <div>
        <span>Level</span>
        <strong id="level">1</strong>
      </div>
    </div>
    <div class="card">
      <h2>Speed</h2>
      <div class="level-progress"><span id="progress"></span></div>
      <button id="restart">Start / Restart</button>
    </div>
  </aside>
</main>
<script>
const canvas = document.getElementById('tetris');
const ctx = canvas.getContext('2d');
ctx.scale(20, 20);
const preview = document.getElementById('preview');
const scoreEl = document.getElementById('score');
const linesEl = document.getElementById('lines');
const levelEl = document.getElementById('level');
const progressEl = document.getElementById('progress');
const restartButton = document.getElementById('restart');
const gridWidth = 12;
const gridHeight = 24;
const nextSize = 4;
const empty = () => Array.from({length: gridWidth}, () => 0);
const arena = Array.from({length: gridHeight}, empty);
let dropCounter = 0;
let dropInterval = 1000;
let lastTime = 0;
let score = 0;
let lines = 0;
let level = 1;
function createPiece(type){
  const shapes = {
    I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
    J: [[2,0,0],[2,2,2],[0,0,0]],
    L: [[0,0,3],[3,3,3],[0,0,0]],
    O: [[4,4],[4,4]],
    S: [[0,5,5],[5,5,0],[0,0,0]],
    T: [[0,6,0],[6,6,6],[0,0,0]],
    Z: [[7,7,0],[0,7,7],[0,0,0]]
  };
  return shapes[type];
}
const pieces = 'IJLOSTZ';
let player = {matrix: null, pos: {x:0,y:0}};
let nextPiece = null;
function resetPlayer(){
  if(!nextPiece){
    nextPiece = createPiece(pieces[(Math.random()*pieces.length)|0]);
  }
  player.matrix = nextPiece;
  nextPiece = createPiece(pieces[(Math.random()*pieces.length)|0]);
  player.pos.y = 0;
  player.pos.x = (gridWidth/2 | 0) - (player.matrix[0].length/2 | 0);
  if(collide(arena, player)){
    arena.forEach(row => row.fill(0));
    score = 0; lines = 0; level = 1;
    dropInterval = 1000;
    updateScore();
  }
  renderPreview();
}
function collide(arena, player){
  const m = player.matrix;
  const o = player.pos;
  for(let y=0;y<m.length;y++){
    for(let x=0;x<m[y].length;x++){
      if(m[y][x] && (
        arena[y+o.y] && arena[y+o.y][x+o.x]) !== 0
      ){
        return true;
      }
    }
  }
  return false;
}
function merge(arena, player){
  player.matrix.forEach((row,y)=>{
    row.forEach((value,x)=>{
      if(value) arena[y+player.pos.y][x+player.pos.x] = value;
    });
  });
}
function rotate(matrix, dir){
  for(let y=0;y<matrix.length;y++){
    for(let x=0;x<y;x++){
      [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
    }
  }
  if(dir > 0) matrix.forEach(row => row.reverse());
  else matrix.reverse();
}
function playerRotate(dir){
  const pos = player.pos.x;
  let offset = 1;
  rotate(player.matrix, dir);
  while(collide(arena, player)){
    player.pos.x += offset;
    offset = -(offset + (offset>0?1:-1));
    if(offset > player.matrix[0].length) return rotate(player.matrix, -dir);
  }
}
function playerDrop(){
  player.pos.y++;
  if(collide(arena, player)){
    player.pos.y--;
    merge(arena, player);
    const cleared = sweep();
    if(cleared){
      lines += cleared;
      score += cleared * cleared * level * 100;
      level = Math.min(15, Math.floor(lines/10)+1);
      dropInterval = 1000 - (level-1)*60;
      progressEl.style.width = `${Math.min(100, (lines%10)*10)}%`;
    }
    updateScore();
    resetPlayer();
  }
  dropCounter = 0;
}
function sweep(){
  let rowCount = 0;
  for(let y=arena.length-1;y>=0;y--){
    if(arena[y].every(value => value !== 0)){
      const animation = arena[y].map(() => 8);
      const frame = () => {
        arena[y] = arena[y].map((cell,i)=> (Date.now()%500 < 250 ? 0 : animation[i]));
        draw();
      };
      const interval = setInterval(frame, 120);
      setTimeout(()=>{
        clearInterval(interval);
        arena.splice(y,1);
        arena.unshift(empty());
        draw();
      }, 400);
      rowCount++;
      y++;
    }
  }
  return rowCount;
}
function draw(){
  ctx.fillStyle = '#05090f';
  ctx.fillRect(0,0,gridWidth,gridHeight);
  drawMatrix(arena, {x:0,y:0});
  drawMatrix(player.matrix, player.pos);
}
function drawMatrix(matrix, offset){
  matrix.forEach((row,y)=>{
    row.forEach((value,x)=>{
      if(value){
        ctx.fillStyle = `hsl(${value*45},100%,50%)`;
        ctx.fillRect(x+offset.x, y+offset.y, 1, 1);
        ctx.strokeStyle = '#05090f';
        ctx.lineWidth = 0.06;
        ctx.strokeRect(x+offset.x, y+offset.y, 1, 1);
      }
    });
  });
}
function renderPreview(){
  preview.innerHTML = '';
  for(let y=0;y<nextSize;y++){
    for(let x=0;x<nextSize;x++){
      const cell = document.createElement('div');
      cell.classList.add('preview-cell');
      const val = nextPiece[y] && nextPiece[y][x];
      if(val){
        cell.style.background = `hsl(${val*45},100%,60%)`;
        cell.style.boxShadow = '0 0 15px rgba(255,255,255,0.3)';
      }
      preview.appendChild(cell);
    }
  }
}
function updateScore(){
  scoreEl.textContent = score;
  linesEl.textContent = lines;
  levelEl.textContent = level;
}
function update(time=0){
  const delta = time - lastTime;
  lastTime = time;
  dropCounter += delta;
  if(dropCounter > dropInterval){
    playerDrop();
  }
  draw();
  requestAnimationFrame(update);
}
document.addEventListener('keydown', event => {
  if(event.key === 'ArrowLeft'){
    player.pos.x--;
    if(collide(arena, player)) player.pos.x++;
  } else if(event.key === 'ArrowRight'){
    player.pos.x++;
    if(collide(arena, player)) player.pos.x--;
  } else if(event.key === 'ArrowDown'){
    playerDrop();
  } else if(event.key === 'ArrowUp'){
    playerRotate(1);
  } else if(event.key === ' ') {
    while(!collide(arena, player)) player.pos.y++;
    player.pos.y--;
    playerDrop();
  }
});
restartButton.addEventListener('click', () => {
  arena.forEach(row => row.fill(0));
  score = 0; lines = 0; level = 1;
  dropInterval = 1000;
  updateScore();
  resetPlayer();
});
resetPlayer();
update();
</script>
</body>
</html>